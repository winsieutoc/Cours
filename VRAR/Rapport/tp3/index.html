<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>RVRA - kfaysal & awolski</title>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="toc.min.js"></script>

<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<link rel="stylesheet" href="style.css">

</head>

<body>

<div id="toc"></div>

<div id="content">

<h1>RVRA - Faysal Ahmed Khaled & Wolski Axel</h1>

<h2>TD3 - Suivi de l'observateur</h2>

<h3>1. Suivi d'un marqueur coloré</h3>
Pour pouvoir sélectionner la couleur pointée par la souris, nous avons utilisé une structure
<strong>FizzyText</strong> qui nous permet d'avoir les canaux de couleur et le coefficient de transparence.
On ajoute alors ces données au menu affiché en haut, à droite de l'écran.
<br>
Ainsi si on active le threshold, il suffit de cliquer sur la couleur à seuiller pour observer une distinction
binaire entre cette couleur (+/- la tolérence) et le reste des pixels de l'image source.
<br>
Pour détecter les contours, nous avons utilisé la fonction CV.findContours qui nous est fournie; à l'aide celle-ci
nous pouvons calculer les coordonnées barycentriques des polygones détectés aux contours. Parmi ces polygones, on
conserve le plus grand. Grace aux coordonnées calculées plus tôt on dessine le cercle englobant.
<br>
Note : Nous n'avons pas implémenté la version HSV, car nos résultats avec la version RGB sont satisfaisants.


<h3>2. Stéréo et tracking</h3>

<h4>2.1. Calibration de la caméra</h4>
Afin de calibrer notre caméra, nous avons suivi le tutoriel indiqué sur la page. Nous avons la matrice
suivante (nous avons arrondie les valeurs par soucis de clarté):
<div class="highlight">
<pre><code class="xml">36.38  0.00  23.61
0.00  36.38 17.70
0.00  0.00  1.00
</code></pre></div>
</p>

<h4>2.2. Calcul de la profondeur</h4>
Nous n'avons pas eu le temps d'implémenté cette partie, car nous voulions d'abord linker le TP2 fait précedement avec ce TP avant de faire la suite.
N'ayant pas reussi à fusionner les deux TP et par manque de temps nous n'avons pas realisé la suite de celui-ci, mais nous avions quelques pistes pour calculer
la distance entre l'objet et l'écran. A l'aide du rayon du cercle englodant ainsi que du théorème de Thalès, nous aurions pu calculer cette distance.


</br>
</div>

<script type="text/javascript">
	$('#toc').toc({
	    'selectors': 'h2,h3,h4', //elements to use as headings
	    'container': 'body', //element to find all selectors in
	    'smoothScrolling': true, //enable or disable smooth scrolling on click
	    'prefix': 'toc', //prefix for anchor tags and class names
	    'onHighlight': function(el) {}, //called when a new section is highlighted
	    'highlightOnScroll': true, //add class to heading that is currently in focus
	    'highlightOffset': 100, //offset to trigger the next headline
	    'anchorName': function(i, heading, prefix) { //custom function for anchor name
	        return prefix+i;
	    },
	    'headerText': function(i, heading, $heading) { //custom function building the header-item text
	        return $heading.text();
	    },
	'itemClass': function(i, heading, $heading, prefix) { // custom function for item class
	  return $heading[0].tagName.toLowerCase();
	}
	});
</script>

</body>
